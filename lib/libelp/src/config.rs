use crate::error::{ConfigurationError, ConfigurationResult, utils};
use serde::{Deserialize, Serialize};
use std::path::Path;

/// Trait for configuration structs generated by the `Configuration` derive macro
/// 
/// This trait provides a unified interface for configuration operations,
/// including loading from files, saving to files, and validation.
pub trait Configuration: Sized + Serialize + for<'de> Deserialize<'de> {
    /// Create a new configuration with default values
    /// 
    /// This method is automatically generated by the `Configuration` derive macro.
    fn new() -> Self;
    /// Load configuration from a TOML file
    /// 
    /// # Arguments
    /// * `path` - Path to the TOML configuration file
    /// 
    /// # Returns
    /// * `Ok(config)` - Successfully loaded configuration
    /// * `Err(error)` - Error loading or parsing the configuration
    /// 
    /// # Example
    /// 
    /// ```rust,no_run
    /// use libelp::{Configuration, ConfigurationResult};
    /// 
    /// #[derive(Configuration)]
    /// struct AppConfig {
    ///     #[config(default = "localhost", note = "Server hostname")]
    ///     host: String,
    ///     #[config(default = 8080, note = "Server port")]
    ///     port: u16,
    /// }
    /// 
    /// fn load_config() -> ConfigurationResult<AppConfig> {
    ///     AppConfig::load_from_file("config.toml")
    /// }
    /// ```
    fn load_from_file(path: impl AsRef<Path>) -> ConfigurationResult<Self> {
        utils::load_from_file(path)
    }

    /// Save configuration to a TOML file
    /// 
    /// # Arguments
    /// * `self` - Configuration to save
    /// * `path` - Path where to save the configuration file
    /// 
    /// # Returns
    /// * `Ok(())` - Successfully saved configuration
    /// * `Err(error)` - Error saving the configuration
    /// 
    /// # Example
    /// 
    /// ```rust,no_run
    /// use libelp::{Configuration, ConfigurationResult};
    /// 
    /// #[derive(Configuration)]
    /// struct AppConfig {
    ///     #[config(default = "localhost", note = "Server hostname")]
    ///     host: String,
    ///     #[config(default = 8080, note = "Server port")]
    ///     port: u16,
    /// }
    /// 
    /// fn save_config(config: AppConfig) -> ConfigurationResult<()> {
    ///     config.save_to_file("config.toml")
    /// }
    /// ```
    fn save_to_file(self, path: impl AsRef<Path>) -> ConfigurationResult<()> {
        utils::save_to_file(&self, path)
    }

    /// Load configuration from a TOML string
    /// 
    /// # Arguments
    /// * `toml_str` - TOML configuration string
    /// 
    /// # Returns
    /// * `Ok(config)` - Successfully parsed configuration
    /// * `Err(error)` - Error parsing the configuration
    fn from_toml_string(toml_str: &str) -> ConfigurationResult<Self> {
        toml::from_str(toml_str)
            .map_err(|e| {
                // Try to extract line and column information from TOML error
                let (line, column) = extract_toml_error_location(&e);
                ConfigurationError::toml_parse_error(
                    e.to_string(),
                    line,
                    column
                )
            })
    }

    /// Convert configuration to a TOML string
    /// 
    /// # Returns
    /// * `Ok(toml_string)` - Successfully serialized configuration
    /// * `Err(error)` - Error serializing the configuration
    fn to_toml_string(&self) -> ConfigurationResult<String> {
        toml::to_string_pretty(self)
            .map_err(|e| ConfigurationError::toml_serialize_error(e.to_string()))
    }

    /// Validate the configuration
    /// 
    /// This method can be overridden by implementors to provide custom validation logic.
    /// The default implementation always returns `Ok(())`.
    /// 
    /// # Returns
    /// * `Ok(())` - Configuration is valid
    /// * `Err(error)` - Configuration validation failed
    fn validate(&self) -> ConfigurationResult<()> {
        Ok(())
    }

    /// Load configuration with fallback to default values
    /// 
    /// This method attempts to load configuration from a file, and if that fails,
    /// it creates a new configuration with default values.
    /// 
    /// # Arguments
    /// * `path` - Path to the TOML configuration file
    /// 
    /// # Returns
    /// * `Ok(config)` - Successfully loaded configuration or default configuration
    /// * `Err(error)` - Error that cannot be resolved with defaults
    fn load_with_defaults(path: impl AsRef<Path>) -> ConfigurationResult<Self> {
        match Self::load_from_file(&path) {
            Ok(config) => {
                // Validate the loaded configuration
                config.validate()?;
                Ok(config)
            }
            Err(ConfigurationError::FileError { .. }) => {
                // File doesn't exist or can't be read, use defaults
                let default_config = Self::new();
                default_config.validate()?;
                Ok(default_config)
            }
            Err(e) => {
                // Other errors (parse errors, etc.) should be reported
                Err(e)
            }
        }
    }
}

/// Extract line and column information from TOML error
fn extract_toml_error_location(error: &toml::de::Error) -> (Option<usize>, Option<usize>) {
    let error_str = error.to_string();
    
    // Look for patterns like "line 5 column 10"
    if let Some(caps) = regex::Regex::new(r"line (\d+) column (\d+)")
        .unwrap()
        .captures(&error_str)
    {
        if let (Ok(line), Ok(column)) = (caps[1].parse(), caps[2].parse()) {
            return (Some(line), Some(column));
        }
    }
    
    // Look for patterns like "at line 5"
    if let Some(caps) = regex::Regex::new(r"at line (\d+)")
        .unwrap()
        .captures(&error_str)
    {
        if let Ok(line) = caps[1].parse() {
            return (Some(line), None);
        }
    }
    
    (None, None)
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde::{Deserialize, Serialize};

    #[derive(Serialize, Deserialize, PartialEq, Debug)]
    struct TestConfig {
        host: String,
        port: u16,
    }

    impl Configuration for TestConfig {
        fn new() -> Self {
            Self {
                host: "localhost".to_string(),
                port: 8080,
            }
        }

        fn validate(&self) -> ConfigurationResult<()> {
            if self.port == 0 {
                return Err(ConfigurationError::validation_error(
                    "Port cannot be zero",
                    Some("port".to_string())
                ));
            }
            Ok(())
        }
    }

    #[test]
    fn test_from_toml_string() {
        let toml_str = r#"
            host = "example.com"
            port = 9090
        "#;
        
        let config = TestConfig::from_toml_string(toml_str).unwrap();
        assert_eq!(config.host, "example.com");
        assert_eq!(config.port, 9090);
    }

    #[test]
    fn test_to_toml_string() {
        let config = TestConfig {
            host: "test.com".to_string(),
            port: 3000,
        };
        
        let toml_str = config.to_toml_string().unwrap();
        assert!(toml_str.contains("test.com"));
        assert!(toml_str.contains("3000"));
    }

    #[test]
    fn test_validation() {
        let valid_config = TestConfig {
            host: "localhost".to_string(),
            port: 8080,
        };
        assert!(valid_config.validate().is_ok());

        let invalid_config = TestConfig {
            host: "localhost".to_string(),
            port: 0,
        };
        assert!(invalid_config.validate().is_err());
    }
}
